# HTTP Header Information Leakage — HTTPレスポンスヘッダーからの情報漏洩

> Webサーバーのレスポンスヘッダーに含まれる技術情報（フレームワーク名やバージョン番号）が外部から丸見えになり、攻撃者がピンポイントで脆弱性を狙えるようになってしまう問題です。

---

## 対象ラボ

| 項目 | 内容 |
|------|------|
| **概要** | `X-Powered-By`, `Server` 等のHTTPレスポンスヘッダーから、使用しているフレームワークやランタイムのバージョンが判明する |
| **攻撃例** | `curl -I http://localhost:3000/` でレスポンスヘッダーを取得し、技術スタックを特定 |
| **技術スタック** | Hono API |
| **難易度** | ★☆☆ 入門 |
| **前提知識** | HTTPリクエスト/レスポンスの基本構造（ヘッダーとボディの違い） |

---

## この脆弱性を理解するための前提

### HTTPレスポンスヘッダーの仕組み

Webサーバーがクライアントにレスポンスを返すとき、ボディ（HTML等）の前に「ヘッダー」と呼ばれるメタ情報を付加する。ヘッダーには `Content-Type` や `Cache-Control` のような制御情報が含まれ、ブラウザはこれを見てレスポンスをどう処理するか決定する。

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Cache-Control: no-cache
Content-Length: 1234

<html>...</html>
```

ヘッダーはブラウザの DevTools (Network タブ) や `curl -I` で誰でも確認できる。つまり、**レスポンスヘッダーに含まれる情報はすべて公開情報**である。

### どこに脆弱性が生まれるのか

多くのWebフレームワークやランタイムは、デフォルトで自身の名前やバージョンをレスポンスヘッダーに含める。開発者がこれを意識せず放置すると、攻撃者に技術スタックの詳細を教えてしまう。

```typescript
// ⚠️ HonoやNode.jsはデフォルトで以下のようなヘッダーを付与する
// 開発者が何も設定しなければ、そのまま外部に公開される

// レスポンスヘッダー例:
// X-Powered-By: Hono        ← フレームワーク名が判明
// Server: Node.js/20.11.0   ← ランタイムとバージョンが判明
// X-Runtime: 0.023          ← 処理時間から内部構成を推測可能
```

これ自体は直接的な攻撃ではないが、**偵察フェーズにおいて攻撃者の効率を大幅に向上させる**情報源となる。

---

## 攻撃の仕組み

![攻撃フロー](diagrams/header-leakage-attack.svg)

### 攻撃のシナリオ

1. **攻撃者** が `curl -I` やブラウザの DevTools を使い、ターゲットにHTTPリクエストを送信する

   レスポンスのボディは不要で、ヘッダーだけ取得すればよい。`HEAD` メソッドやブラウザの Network タブで十分であり、特別なツールは不要。

   ```bash
   $ curl -I http://target:3000/
   ```

2. **Webサーバー** がレスポンスヘッダーに技術情報を含めて返す

   サーバーはデフォルト設定のまま動作しているため、フレームワーク名やランタイムバージョンがそのままヘッダーに含まれる。

   ```
   HTTP/1.1 200 OK
   X-Powered-By: Hono
   Server: Node.js/20.11.0
   X-Runtime: 0.023
   Content-Type: text/html; charset=utf-8
   ```

3. **攻撃者** が取得した情報を分析し、技術スタックを特定する

   `Hono` + `Node.js 20.11.0` という情報から、フレームワークとランタイムの正確なバージョンが判明する。

4. **攻撃者** が CVE データベースや Exploit DB で既知の脆弱性を検索する

   特定されたバージョンに対して `CVE-20xx-xxxx Node.js 20.11` のように検索し、攻撃に使える既知の脆弱性を探す。

5. **攻撃者** が特定した脆弱性を利用して標的型攻撃を実行する

   バージョン固有の脆弱性を突くエクスプロイトを使い、手当たり次第ではなくピンポイントの攻撃を仕掛ける。偵察情報がなければ試行錯誤が必要だった攻撃が、高い成功率で実行できる。

### なぜ成功するのか

| 条件 | 説明 |
|------|------|
| デフォルト設定の放置 | フレームワークやランタイムが自動付与するヘッダーを削除していない |
| ヘッダーの公開性 | HTTPレスポンスヘッダーは認証なしで誰でも取得できる |
| バージョン情報の具体性 | 正確なバージョン番号が含まれるため、既知脆弱性の特定が容易 |

### 被害の範囲

- **機密性**: 技術スタック・バージョン情報が漏洩し、攻撃計画の材料になる
- **完全性**: 直接的な改ざんはないが、特定された脆弱性を通じて間接的にデータ改ざんにつながる可能性がある
- **可用性**: 情報漏洩自体はサービスに影響しないが、後続の攻撃でサービス停止を招く可能性がある

---

## 対策

![対策フロー](diagrams/header-leakage-defense.svg)

### 根本原因

サーバーが「外部に公開する必要のない技術情報」をレスポンスヘッダーに含めたまま運用していること。HTTPレスポンスヘッダーは誰でも閲覧できるため、不要な情報は一切含めるべきではない。

### 安全な実装

不要なヘッダーをミドルウェアで削除する。Hono では `secureHeaders` ミドルウェアが利用でき、`X-Powered-By` 等の除去とセキュリティヘッダーの付与を同時に行える。

```typescript
// ✅ ミドルウェアで不要なヘッダーを削除し、セキュリティヘッダーを付与する
// X-Powered-By を削除することで、フレームワーク名を隠蔽する
// さらに X-Content-Type-Options 等の保護ヘッダーを追加する

import { Hono } from "hono";

const app = new Hono();

// 不要なヘッダーを削除するミドルウェア
app.use("*", async (c, next) => {
  await next();
  c.res.headers.delete("X-Powered-By");
  c.res.headers.delete("Server");
  // セキュリティヘッダーを付与
  c.res.headers.set("X-Content-Type-Options", "nosniff");
});
```

**なぜ安全か**: `X-Powered-By` や `Server` ヘッダーを削除することで、攻撃者がレスポンスヘッダーから技術スタックを特定できなくなる。フレームワーク名やバージョンがわからなければ、既知脆弱性の検索が困難になり、攻撃の効率が大幅に低下する。

#### 脆弱 vs 安全: コード比較

```diff
  app.use("*", async (c, next) => {
    await next();
-   // ヘッダーをそのまま返す（フレームワーク名・バージョンが露出）
+   c.res.headers.delete("X-Powered-By");
+   c.res.headers.delete("Server");
+   c.res.headers.set("X-Content-Type-Options", "nosniff");
  });
```

脆弱版ではデフォルトのヘッダーがそのまま外部に返される。安全版ではミドルウェアで不要なヘッダーを削除し、代わりにセキュリティヘッダーを付与している。

### その他の防御策

| 対策 | 種類 | 説明 |
|------|------|------|
| 不要ヘッダーの削除 | 根本対策 | `X-Powered-By`, `Server` 等をアプリケーション層で除去する |
| リバースプロキシでのヘッダー制御 | 多層防御 | Nginx 等で `proxy_hide_header X-Powered-By;` を設定し、バックエンドの情報を隠蔽する |
| セキュリティヘッダーの付与 | 多層防御 | `X-Content-Type-Options`, `X-Frame-Options` 等の保護用ヘッダーを積極的に設定する |
| 依存パッケージの定期更新 | 多層防御 | 万が一バージョンが漏洩しても、最新版であれば既知脆弱性のリスクを低減できる |

---

## ハンズオン手順

### Step 1: 脆弱バージョンで攻撃を体験

**ゴール**: HTTPレスポンスヘッダーからサーバーの技術情報を取得できることを確認する

1. 開発サーバーを起動する

2. 脆弱なエンドポイントに `curl -I` でリクエストを送る

   ```bash
   # レスポンスヘッダーだけを取得する
   curl -I http://localhost:3000/api/labs/header-leakage/vulnerable/
   ```

3. レスポンスヘッダーを確認する

   - `X-Powered-By` ヘッダーにフレームワーク名が含まれているか
   - `Server` ヘッダーにランタイムとバージョンが含まれているか
   - ブラウザの DevTools (Network タブ) でも同じ情報を確認してみる
   - **この結果が意味すること**: 攻撃者はこの情報だけで CVE データベースを検索し、バージョン固有の脆弱性を特定できる

### Step 2: 安全バージョンで防御を確認

**ゴール**: 同じリクエストで技術情報が取得できないことを確認する

1. 安全なエンドポイントに同じリクエストを送る

   ```bash
   # 同じリクエストを安全なバージョンに対して実行
   curl -I http://localhost:3000/api/labs/header-leakage/secure/
   ```

2. レスポンスヘッダーの違いを比較する

   - `X-Powered-By` ヘッダーが消えているか
   - `Server` ヘッダーが消えている、または汎用的な値に変わっているか
   - 代わりにセキュリティヘッダー（`X-Content-Type-Options` 等）が追加されているか

3. コードの差分を確認する

   - `backend/src/labs/header-leakage.ts` の脆弱版と安全版を比較
   - **どの行が違いを生んでいるか** に注目

### 確認ポイント

以下を自分の言葉で説明できれば、このラボは完了です:

- [ ] HTTPレスポンスヘッダーに技術情報が含まれるのはなぜか（デフォルト設定の問題）
- [ ] 攻撃者はヘッダー情報をどう利用するか（偵察 → CVE検索 → 標的型攻撃）
- [ ] 不要なヘッダーを削除することでなぜ攻撃が困難になるのか
- [ ] セキュリティヘッダーの付与が「守り」としてどう機能するか

---

## 実装メモ

| 項目 | パス |
|------|------|
| 脆弱エンドポイント | `/api/labs/header-leakage/vulnerable/` |
| 安全エンドポイント | `/api/labs/header-leakage/secure/` |
| バックエンド | `backend/src/labs/header-leakage.ts` |
| フロントエンド | `frontend/src/pages/HeaderLeakage.tsx` |

- 脆弱版: デフォルトのヘッダーをそのまま返す
- 安全版: `X-Powered-By`, `Server` を削除し、セキュリティヘッダーを付与する
- DevTools の Network タブでも確認可能（ブラウザでの体験も推奨）

---

## 現実世界での事例

| 年 | インシデント | 概要 |
|----|-------------|------|
| 2017 | Equifax 情報漏洩 | Apache Struts のバージョン情報がヘッダーから判明し、既知の脆弱性 (CVE-2017-5638) を特定・悪用された。約1.4億人の個人情報が漏洩 |
| 継続的 | Shodan / Censys による大規模スキャン | インターネット全体をスキャンし、`Server` / `X-Powered-By` ヘッダーから脆弱なバージョンのサーバーを自動検出するサービスが存在する |

---

## 関連ラボ

| ラボ | 関連性 |
|------|--------|
| [不要なヘッダー露出](header-exposure.md) | 同じHTTPヘッダーの問題を異なる観点（セキュリティヘッダーの欠如）で扱う |
| [エラーメッセージからの情報漏洩](error-message-leakage.md) | エラーレスポンスのボディからも技術情報が漏洩する。ヘッダー漏洩と組み合わせると偵察精度が上がる |

---

## 参考資料

- [OWASP - HTTP Headers](https://owasp.org/www-project-secure-headers/)
- [CWE-200: Exposure of Sensitive Information to an Unauthorized Actor](https://cwe.mitre.org/data/definitions/200.html)
